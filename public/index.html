<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Email Client</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìß</text></svg>">
  <style>
    /* STRICT monochrome: only black (#000) and white (#fff) */
    body {font-family: Arial, sans-serif; margin: 0; padding: 0; background:#fff; color:#000;}
    h1 {margin:0 0 16px 0;}

    /* Layout: 20% menu (left) + 80% board (right) */
    #layout{
      display:flex;
      min-height:100vh;
    }
    #sidebar{
      flex:0 0 5%;
      min-width:60px;
      border-right:1px solid #000;
      padding:20px;
      box-sizing:border-box;
      transition:flex-basis 0.2s ease;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #sidebar:hover{
      flex-basis:11%;
    }
    #board{
      flex:1;
      padding:20px;
      box-sizing:border-box;
    }

    #emails {max-width:800px; margin:0; background:#fff; border:1px solid #000; padding:20px;}
    ul {list-style:none; padding:0; margin:0;}
    li {padding:12px; border-bottom:1px solid #000; cursor:pointer;}
    li:hover {background:#000; color:#fff;}
    .sub {font-weight:bold;}
    .meta {font-size:.9em;}
    pre {white-space:pre-wrap; background:#fff; padding:15px; border:1px solid #000;}

    /* Inputs (monochrome) */
    input, textarea{
      width:100%;
      padding:8px;
      border:1px solid #000;
      background:#fff;
      color:#000;
      box-sizing:border-box;
      font-family:inherit;
    }
    textarea{ min-height:150px; resize:vertical; }

    /* Minimal monochrome modal (no browser alerts/confirms) */
    .modal-overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center;
      z-index:10000;
      padding:20px;
    }
    .modal{
      width:min(560px, 100%);
      background:#fff;
      color:#000;
      border:1px solid #000;
      box-shadow:0 12px 32px rgba(0,0,0,.25);
    }
    .modal-header{
      padding:14px 16px;
      border-bottom:1px solid #000;
      font-weight:700;
      letter-spacing:.2px;
    }
    .modal-body{
      padding:14px 16px;
      font-size:14px;
      line-height:1.45;
      white-space:pre-wrap;
      word-break:break-word;
    }
    .modal-actions{
      padding:12px 16px;
      border-top:1px solid #000;
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    /* Email reader modal - Microsoft Outlook style */
    .email-modal-overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.2);
      display:flex; align-items:center; justify-content:center;
      z-index:10001;
      padding:10px;
      overflow-y: auto; /* Allow modal overlay to scroll if content is too tall */
    }
    .email-modal{
      width:min(1200px, 95vw);
      height:min(800px, 90vh);
      background:#fff;
      color:#000;
      border:1px solid #000;
      box-shadow:0 12px 32px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
      max-height: 90vh; /* Ensure modal doesn't exceed viewport height */
    }

    /* Prevent body scroll when modal is open */
    body.modal-open {
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    .email-modal-header{
      padding:16px 20px;
      border-bottom:1px solid #000;
      background:#f8f8f8;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .email-modal-title{
      font-weight:700;
      font-size:16px;
      margin:0;
      flex:1;
    }
    .email-modal-close{
      background:none;
      border:1px solid #000;
      color:#000;
      cursor:pointer;
      padding:6px 12px;
      font-size:14px;
    }
    .email-modal-close:hover{
      background:#000;
      color:#fff;
    }
    .email-modal-meta{
      padding:12px 20px;
      border-bottom:1px solid #000;
      background:#fafafa;
      font-size:14px;
    }
    .email-modal-from{
      font-weight:600;
      margin-bottom:4px;
    }
    .email-modal-date{
      color:#666;
      font-size:13px;
    }
    .email-modal-body{
      flex:1;
      padding:20px;
      overflow-y:auto;
      font-family:Arial, sans-serif;
      line-height:1.5;
      white-space:pre-wrap;
      word-wrap:break-word;
    }
    .btn{
      appearance:none;
      border:1px solid #000;
      background:#fff;
      color:#000;
      padding:8px 12px;
      cursor:pointer;
      font-weight:600;
    }
    .btn:hover{ background:#000; color:#fff; }
    .btn.primary{ background:#000; color:#fff; }
    .btn.primary:hover{ background:#fff; color:#000; }

    /* Page buttons */
    .topbar{ margin-bottom:15px; display:flex; gap:10px; flex-wrap:wrap; }
    .page-btn{
      border:1px solid #000;
      background:#fff;
      color:#000;
      padding:10px 16px;
      cursor:pointer;
      font-weight:700;
      text-align:center;
    }
    .page-btn:hover{ background:#000; color:#fff; }
    /* Sidebar buttons: make square and center the letter precisely */
    #sidebar .page-btn {
      width:44px;
      height:44px;
      padding:0;
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      overflow:hidden;
      white-space:nowrap;
      transition: width 0.18s ease, padding 0.18s ease, justify-content 0.18s ease;
    }
    /* When sidebar is hovered, expand buttons to fill sidebar width and left-align text */
    #sidebar:hover .page-btn {
      width:100%;
      padding:8px 10px;
      justify-content:center;
      text-align:center;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .notice{
      padding:12px;
      border-bottom:1px solid #000;
      background:#fff;
      color:#000;
      font-weight:700;
    }

    /* Tabs (board top) */
    .tabs-bar{
      display:flex;
      gap:4px;
      margin-bottom:10px;
    }
    .tab{
      border:1px solid #000;
      background:#fff;
      color:#000;
      padding:6px 10px;
      cursor:pointer;
      font-weight:600;
      position:relative;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .tab-active{
      background:#000;
      color:#fff;
    }
    .tab-close{
      display:none;
      border:none;
      background:transparent;
      color:inherit;
      cursor:pointer;
      padding:0;
      width:16px;
      height:16px;
      font-size:14px;
      line-height:1;
    }
    .tab:hover .tab-close{
      display:block;
    }
  </style>
</head>
<body>
  <div id="layout">
    <div id="sidebar">
      <button id="menuEmail" class="page-btn" data-short="E" data-full="Email">E</button>
      <button id="menuSettings" class="page-btn" data-short="S" data-full="Setting">S</button>
    </div>
    <div id="board">
      <div id="tabsBar" class="tabs-bar"></div>

      <!-- Welcome / future dashboard -->
      <div id="welcomePanel" style="border:1px solid #000; padding:20px; margin-bottom:20px;">
        <h3>Welcome</h3>
        <p class="meta">
          This board will become the main dashboard: open tasks, follow-ups, and status overview.
          For now, use the left menu to open <strong>Setting</strong> and configure email profiles.
        </p>
      </div>

      <!-- Profiles list (landing page for settings) -->
      <div id="profilesListPanel" style="border:1px solid #000; padding:20px; margin-bottom:20px; display:none;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
          <h3>Email Profiles</h3>
          <button id="addProfileBtn" class="page-btn" style="font-size:18px; padding:8px 16px;">+</button>
        </div>
        <div id="profilesList"></div>
      </div>

      <!-- Settings board (IMAP/SMTP profile edit form) -->
      <div id="settingsPanel" style="border:1px solid #000; padding:20px; margin-bottom:20px; display:none;">
        <form id="settingsForm">
          <h3>Profile &amp; Connection Settings</h3>
        <div class="row" style="margin-bottom:10px;">
          <div style="flex:1;">
            <label for="cfgMailUser">MAIL_USER</label>
            <input id="cfgMailUser" type="email">
          </div>
          <div style="flex:1;">
            <label for="cfgMailPass">MAIL_PASS</label>
            <div style="position:relative;">
              <input id="cfgMailPass" type="password" autocomplete="current-password" style="padding-right:30px;">
              <button id="togglePassword" type="button" style="position:absolute; right:5px; top:50%; transform:translateY(-50%); background:none; border:none; cursor:pointer; color:#000; font-size:14px;">üëÅÔ∏è</button>
            </div>
          </div>
        </div>

        <h4>IMAP (incoming)</h4>
        <div class="row" style="margin-bottom:10px;">
          <div style="flex:2;">
            <label for="cfgImapHost">IMAP_HOST</label>
            <input id="cfgImapHost" type="text">
          </div>
          <div style="flex:1;">
            <label for="cfgImapPort">IMAP_PORT</label>
            <input id="cfgImapPort" type="number">
          </div>
          <div style="flex:1;">
            <label for="cfgImapTls">IMAP_TLS (true/false)</label>
            <input id="cfgImapTls" type="text">
          </div>
        </div>

        <h4>SMTP (outgoing)</h4>
        <div class="row" style="margin-bottom:10px;">
          <div style="flex:2;">
            <label for="cfgSmtpHost">SMTP_HOST</label>
            <input id="cfgSmtpHost" type="text">
          </div>
          <div style="flex:1;">
            <label for="cfgSmtpPort">SMTP_PORT</label>
            <input id="cfgSmtpPort" type="number">
          </div>
          <div style="flex:1;">
            <label for="cfgSmtpSecure">SMTP_SECURE (true/false)</label>
            <input id="cfgSmtpSecure" type="text">
          </div>
        </div>

        <h4>Server</h4>
        <div class="row" style="margin-bottom:10px;">
          <div style="flex:1;">
            <label for="cfgPort">PORT</label>
            <input id="cfgPort" type="number">
          </div>
        </div>

        <div class="row">
          <button id="saveConfigBtn" class="page-btn">Save Settings</button>
          <button id="dummyFillSettingsBtn" class="page-btn" type="button">Auto Fill (Random)</button>
        </div>
        <p class="meta" id="settingsNote"></p>
        </form>
      </div>

      <!-- Email UI (next step; hidden for now) -->
      <div id="emails" style="margin:0; display:none; width:100%;">
        <div class="topbar">
          <button id="composeBtn" class="page-btn">Compose</button>
          <button id="testSendBtn" class="page-btn">Send Test Email</button>
          <button id="testSmtpBtn" class="page-btn">Test SMTP Connection</button>
        </div>
        <div id="composeForm" style="display:none; background:#fff; padding:15px; border:1px solid #000; margin-bottom:15px;">
          <h3>Compose Email</h3>
          <input type="email" id="toEmail" placeholder="To:" style="margin-bottom:10px;">
          <input type="text" id="subjectEmail" placeholder="Subject:" style="margin-bottom:10px;">
          <textarea id="bodyEmail" placeholder="Message:" style="margin-bottom:10px;"></textarea>
          <div class="row">
            <button id="sendBtn" class="page-btn">Send</button>
            <button id="cancelBtn" class="page-btn">Cancel</button>
            <button id="dummyFillComposeBtn" class="page-btn" type="button" style="margin-left:auto;">Dummy Fill</button>
          </div>
        </div>
        <table id="emailTable" style="width:100%; border-collapse:collapse; border:1px solid #000; margin-bottom:15px;">
          <thead>
            <tr style="background:#fff;">
              <th style="padding:8px; border:1px solid #000; text-align:left; font-weight:bold;">Date</th>
              <th style="padding:8px; border:1px solid #000; text-align:left; font-weight:bold;">Send Email</th>
              <th style="padding:8px; border:1px solid #000; text-align:left; font-weight:bold;">Subject</th>
              <th style="padding:8px; border:1px solid #000; text-align:left; font-weight:bold;">Context</th>
              <th style="padding:8px; border:1px solid #000; text-align:left; font-weight:bold;">Attachment</th>
            </tr>
            <tr style="background:#fff;">
              <th style="padding:8px; border:1px solid #000;">
                <input type="text" id="dateSearch" placeholder="Search date..." style="width:100%; border:1px solid #000; padding:4px; box-sizing:border-box;">
              </th>
              <th style="padding:8px; border:1px solid #000;">
                <input type="text" id="senderSearch" placeholder="Search sender..." style="width:100%; border:1px solid #000; padding:4px; box-sizing:border-box;">
              </th>
              <th style="padding:8px; border:1px solid #000;">
                <input type="text" id="subjectSearch" placeholder="Search subject..." style="width:100%; border:1px solid #000; padding:4px; box-sizing:border-box;">
              </th>
              <th style="padding:8px; border:1px solid #000;">
                <input type="text" id="contextSearch" placeholder="Search content..." style="width:100%; border:1px solid #000; padding:4px; box-sizing:border-box;">
              </th>
              <th style="padding:8px; border:1px solid #000;">
                <input type="text" id="attachmentSearch" placeholder="Search attachments..." style="width:100%; border:1px solid #000; padding:4px; box-sizing:border-box;">
              </th>
            </tr>
          </thead>
          <tbody id="emailTableBody"></tbody>
        </table>

        <!-- Email Reader Modal (Microsoft Outlook style) -->
        <div id="emailModal" class="email-modal-overlay" style="display:none;">
          <div class="email-modal">
            <div class="email-modal-header">
              <h2 id="emailModalSubject" class="email-modal-title">Email Subject</h2>
              <div style="display:flex; gap:10px; align-items:center;">
                <button id="emailModalCreateTask" class="page-btn" style="font-size:12px; padding:4px 8px;">Create Task</button>
                <button id="emailModalClose" class="email-modal-close">√ó</button>
              </div>
            </div>
            <div class="email-modal-meta">
              <div id="emailModalFrom" class="email-modal-from">From: sender@example.com</div>
              <div id="emailModalDate" class="email-modal-date">Date: 2024-01-15</div>
            </div>
            <div id="emailModalBody" class="email-modal-body">
              Email content will appear here...
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const tabsBar = document.getElementById('tabsBar');
    const welcomePanel = document.getElementById('welcomePanel');
    const profilesListPanel = document.getElementById('profilesListPanel');
    const settingsPanel = document.getElementById('settingsPanel');

    const menuSettingsBtn = document.getElementById('menuSettings');
    const addProfileBtn = document.getElementById('addProfileBtn');
    const profilesListEl = document.getElementById('profilesList');
    const settingsNoteEl = document.getElementById('settingsNote');
    
    // Store current email list for quick access
    let currentEmails = [];
    let currentLoadController = null; // Track current load request
    let currentEmailMeta = null; // Track currently shown email (for task creation)
    let currentEmailModalMeta = null; // Track email in modal (for task creation)

    // -------- SETTINGS (board) --------
    const cfgMailUser = document.getElementById('cfgMailUser');
    const cfgMailPass = document.getElementById('cfgMailPass');
    const cfgImapHost = document.getElementById('cfgImapHost');
    const cfgImapPort = document.getElementById('cfgImapPort');
    const cfgImapTls = document.getElementById('cfgImapTls');
    const cfgSmtpHost = document.getElementById('cfgSmtpHost');
    const cfgSmtpPort = document.getElementById('cfgSmtpPort');
    const cfgSmtpSecure = document.getElementById('cfgSmtpSecure');
    const cfgPort = document.getElementById('cfgPort');
    const saveConfigBtn = document.getElementById('saveConfigBtn');
    const dummyFillSettingsBtn = document.getElementById('dummyFillSettingsBtn');
    const togglePasswordBtn = document.getElementById('togglePassword');

    async function loadConfig() {
      try {
        const res = await fetch('/api/config', { cache: 'no-cache' });
        const data = await res.json();
        if (!data.success) {
          await showCopyableError('Load Settings Error', JSON.stringify(data, null, 2));
          return;
        }
        const cfg = data.config || {};
        cfgMailUser.value = cfg.MAIL_USER || '';
        cfgMailPass.value = cfg.MAIL_PASS || '';
        cfgImapHost.value = cfg.IMAP_HOST || '';
        cfgImapPort.value = cfg.IMAP_PORT || '';
        cfgImapTls.value = cfg.IMAP_TLS || '';
        cfgSmtpHost.value = cfg.SMTP_HOST || '';
        cfgSmtpPort.value = cfg.SMTP_PORT || '';
        cfgSmtpSecure.value = cfg.SMTP_SECURE || '';
        cfgPort.value = cfg.PORT || '';
        settingsNoteEl.textContent = data.note || 'Changes require server restart.';
      } catch (err) {
        await showCopyableError('Load Settings Error', `Error loading config: ${err.message}`);
      }
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randomFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function fillDummyForm(panelEl) {
      const controls = Array.from(panelEl.querySelectorAll('input, textarea, select'));

      for (const el of controls) {
        if (el.disabled) continue;
        if (el.tagName === 'INPUT') {
          const type = (el.type || 'text').toLowerCase();
          if (type === 'button' || type === 'submit' || type === 'reset' || type === 'hidden') continue;
        }

        // Skip hidden/inactive elements
        if (el.offsetParent === null) continue;

        const id = (el.id || '').toLowerCase();
        const name = (el.name || '').toLowerCase();
        const labelEl = el.id ? panelEl.querySelector(`label[for="${CSS.escape(el.id)}"]`) : null;
        const label = (labelEl?.textContent || '').toLowerCase();
        const hint = `${id} ${name} ${label}`;

        if (el.tagName === 'SELECT') {
          const enabledOptions = Array.from(el.options).filter(o => !o.disabled && o.value !== '');
          if (enabledOptions.length) el.value = randomFrom(enabledOptions).value;
          continue;
        }

        if (el.tagName === 'TEXTAREA') {
          if (!el.value.trim()) el.value = 'Dummy text ' + randomInt(1000, 9999);
          el.dispatchEvent(new Event('input', { bubbles: true }));
          continue;
        }

        // INPUT types
        const type = (el.type || 'text').toLowerCase();
        if (type === 'checkbox') {
          el.checked = true;
          el.dispatchEvent(new Event('change', { bubbles: true }));
          continue;
        }
        if (type === 'radio') {
          el.checked = true;
          el.dispatchEvent(new Event('change', { bubbles: true }));
          continue;
        }
        if (type === 'number') {
          if (!String(el.value || '').trim()) el.value = String(randomInt(1, 9999));
          el.dispatchEvent(new Event('input', { bubbles: true }));
          continue;
        }
        if (type === 'email') {
          if (!el.value.trim()) el.value = `dummy${randomInt(10, 999)}@example.com`;
          el.dispatchEvent(new Event('input', { bubbles: true }));
          continue;
        }
        if (type === 'password') {
          if (!el.value) el.value = 'DummyPass' + randomInt(1000, 9999);
          el.dispatchEvent(new Event('input', { bubbles: true }));
          continue;
        }

        // Heuristics based on id/label
        if (!el.value.trim()) {
          if (hint.includes('imap_host')) el.value = 'imap.example.com';
          else if (hint.includes('smtp_host')) el.value = 'smtp.example.com';
          else if (hint.includes('host')) el.value = 'localhost';
          else if (hint.includes('imap_port')) el.value = '993';
          else if (hint.includes('smtp_port')) el.value = '465';
          else if (hint.includes('port')) el.value = '3001';
          else if (hint.includes('tls') || hint.includes('secure')) el.value = 'true';
          else el.value = 'Dummy ' + randomInt(1000, 9999);
        }
        el.dispatchEvent(new Event('input', { bubbles: true }));
      }
    }

    dummyFillSettingsBtn.onclick = () => {
      fillDummyForm(settingsPanel);
    };

    togglePasswordBtn.onclick = () => {
      const passwordInput = document.getElementById('cfgMailPass');
      const isPassword = passwordInput.type === 'password';
      passwordInput.type = isPassword ? 'text' : 'password';
      togglePasswordBtn.textContent = isPassword ? 'üôà' : 'üëÅÔ∏è';
    };

    saveConfigBtn.onclick = async () => {
      try {
        // 1) Validate settings form completeness FIRST (before any profile-name prompt)
        const inputs = Array.from(settingsPanel.querySelectorAll('input'));
        const missingLabels = [];

        for (const input of inputs) {
          // Skip inputs that are not actionable/visible
          if (input.disabled) continue;
          if (input.type === 'button' || input.type === 'submit' || input.type === 'reset') continue;

          // Skip hidden inputs or anything inside a hidden container
          // (offsetParent is null when display:none or not in layout)
          if (input.type === 'hidden' || input.offsetParent === null) continue;

          const value = (input.value ?? '').toString().trim();
          if (value) continue;

          // Derive label from <label for="..."> when possible, fallback to id/name
          const labelEl = settingsPanel.querySelector(`label[for="${CSS.escape(input.id)}"]`);
          const label = (labelEl?.textContent || input.name || input.id || 'Unnamed field').trim();
          missingLabels.push(label);
        }

        if (missingLabels.length) {
          await showModal({
            title: 'Incomplete fields',
            body: `Please fill in:\n${missingLabels.join('\n')}`
          });
          return;
        }

        // 2) Load existing profiles (for duplicate name check)
        const listRes = await fetch('/api/profiles', { cache: 'no-cache' });
        const listData = await listRes.json();
        const profiles = listData?.profiles || [];

        // 3) Prompt for profile name (required + unique)
        let profileName = currentEditingProfileId ? (profiles.find(p => p.id === currentEditingProfileId)?.name || '') : '';
        while (true) {
          const result = await showTextInputModal({
            title: 'Profile name',
            label: 'Profile name (required):',
            initialValue: profileName,
            okText: 'OK',
            cancelText: 'Cancel'
          });

          if (!result.ok) {
            return; // user cancelled
          }

          profileName = (result.value || '').trim();
          if (!profileName) {
            await showModal({ title: 'Profile name required', body: 'Please enter a profile name.' });
            continue;
          }
          const exists = profiles.some(p => String(p.name || '').toLowerCase() === profileName.toLowerCase() && p.id !== currentEditingProfileId);
          if (exists) {
            await showModal({ title: 'Name already exists', body: `Profile name "${profileName}" already exists. Please use a different name.` });
            continue;
          }
          break;
        }

        const payload = {
          name: profileName,
          remark: profileName,
          mailUser: cfgMailUser.value.trim(),
          mailPass: cfgMailPass.value,
          imapHost: cfgImapHost.value.trim(),
          imapPort: cfgImapPort.value.trim(),
          imapTls: cfgImapTls.value.trim(),
          smtpHost: cfgSmtpHost.value.trim(),
          smtpPort: cfgSmtpPort.value.trim(),
          smtpSecure: cfgSmtpSecure.value.trim(),
          port: cfgPort.value.trim(),
          isActive: 0,
        };

        const url = currentEditingProfileId ? `/api/profiles/${currentEditingProfileId}` : '/api/profiles';
        const method = currentEditingProfileId ? 'PUT' : 'POST';

        const res = await fetch(url, {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json();
        if (!data.success) {
          await showCopyableError('Save Profile Error', JSON.stringify(data, null, 2));
          return;
        }

        settingsHasUnsavedChanges = false;
        await loadProfilesList();

        await showModal({
          title: 'Profile Saved',
          body: `Profile "${profileName}" saved.\nIf you want it to take effect for sending/receiving email, select the profile and implement activation logic (next step).`,
        });

        // Close editor after saving
        settingsPanel.style.display = 'none';
        currentEditingProfileId = null;
      } catch (err) {
        await showCopyableError('Save Profile Error', `Error saving profile: ${err.message}`);
      }
    };

    // Track changes to settings form
    [cfgMailUser, cfgMailPass, cfgImapHost, cfgImapPort, cfgImapTls, cfgSmtpHost, cfgSmtpPort, cfgSmtpSecure, cfgPort].forEach(input => {
      input.addEventListener('input', () => {
        settingsHasUnsavedChanges = true;
      });
    });

    // Track if settings have unsaved changes
    let settingsHasUnsavedChanges = false;
    let currentEditingProfileId = null; // null means creating new profile

    // --- Tabs handling (welcome + future boards) ---
    function ensureTab(id, label) {
      let tab = tabsBar.querySelector(`[data-tab-id="${id}"]`);
      if (!tab) {
        tab = document.createElement('div');
        tab.className = 'tab';
        tab.dataset.tabId = id;
        
        const labelSpan = document.createElement('span');
        labelSpan.textContent = label;
        tab.appendChild(labelSpan);
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'tab-close';
        closeBtn.textContent = '√ó';
        closeBtn.onclick = async (e) => {
          e.stopPropagation();
          await closeTab(id);
        };
        tab.appendChild(closeBtn);
        
        tab.onclick = () => activateTab(id);
        tabsBar.appendChild(tab);
      }
      return tab;
    }

    async function closeTab(id) {
      // Always prompt warning before closing profiles tab
      if (id === 'profiles') {
        const confirmed = await showModal({
          title: 'Warning',
          body: 'Closing this tag will lose everything.',
          okText: 'Close',
          cancelText: 'Cancel'
        });
        if (!confirmed) {
          return; // Do not close if user cancels
        }
      }
      
      // Hide all panels first
      settingsPanel.style.display = 'none';
      profilesListPanel.style.display = 'none';
      
      // Remove tab
      const tab = tabsBar.querySelector(`[data-tab-id="${id}"]`);
      if (tab) {
        tab.remove();
      }
      
      // Always switch to welcome when closing a tab
      activateTab('welcome');
      
      // Reset unsaved changes flag
      settingsHasUnsavedChanges = false;
    }

    function activateTab(id) {
      // Visual active state
      Array.from(tabsBar.children).forEach(el => {
        if (el.dataset.tabId === id) {
          el.classList.add('tab-active');
        } else {
          el.classList.remove('tab-active');
        }
      });

      // Panels
      welcomePanel.style.display = id === 'welcome' ? 'block' : 'none';
      profilesListPanel.style.display = id === 'profiles' ? 'block' : 'none';
      document.getElementById('emails').style.display = id === 'emails' ? 'block' : 'none';
      // settingsPanel is shown inline within profiles when a profile is clicked
      settingsPanel.style.display = 'none';

      if (id === 'profiles') {
        loadProfilesList().catch(() => {});
      }
    }

    // Profiles list functions
    async function loadProfilesList() {
      try {
        const res = await fetch('/api/profiles', { cache: 'no-cache' });
        const data = await res.json();
        if (!data.success) {
          await showCopyableError('Load Profiles Error', JSON.stringify(data, null, 2));
          return;
        }
        const profiles = data.profiles || [];
        
        // If no profiles, create default "longriver.com"
        if (profiles.length === 0) {
          await createDefaultProfile();
          return loadProfilesList(); // Reload after creating default
        }

        profilesListEl.innerHTML = '';
        profiles.forEach(p => {
          const item = document.createElement('div');
          item.style.cssText = 'padding:12px; border-bottom:1px solid #000; cursor:pointer;';
          item.innerHTML = `
            <div style="font-weight:700;">${p.name || 'Unnamed'}</div>
            <div class="meta">${p.remark || ''}</div>
            <div class="meta" style="font-size:0.85em;">${p.mailUser || ''} | Active: ${p.isActive ? 'Yes' : 'No'}</div>
          `;
          item.innerHTML += `<div style="margin-top:6px; display:flex; gap:6px;">
              <button class="btn ${p.isActive ? 'primary' : ''}" data-action="activate">${p.isActive ? 'Active' : 'Activate'}</button>
              <button class="btn" data-action="edit">Edit</button>
              <button class="btn" data-action="delete">Delete</button>
            </div>`;
          item.onclick = (e) => {
            const action = e.target?.dataset?.action;
            if (action === 'activate') {
              e.stopPropagation();
              (async () => {
                // Toggle active state
                const newActiveState = p.isActive ? 0 : 1;
                const res = await fetch(`/api/profiles/${p.id}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ ...p, isActive: newActiveState })
                });
                const data = await res.json();
                if (!data.success) {
                  await showCopyableError('Update Profile Error', JSON.stringify(data, null, 2));
                  return;
                }
                await loadProfilesList(); // Refresh the list
              })();
            } else if (action === 'edit') {
              e.stopPropagation();
              // Edit profile
              currentEditingProfileId = p.id;
              settingsPanel.style.display = 'block';
              cfgMailUser.value = p.mailUser || '';
              cfgMailPass.value = p.mailPass || '';
              cfgImapHost.value = p.imapHost || '';
              cfgImapPort.value = p.imapPort || '';
              cfgImapTls.value = p.imapTls || 'true';
              cfgSmtpHost.value = p.smtpHost || '';
              cfgSmtpPort.value = p.smtpPort || '';
              cfgSmtpSecure.value = p.smtpSecure || 'true';
              cfgPort.value = p.port || '';
            } else if (action === 'delete') {
              e.stopPropagation();
              (async () => {
                const ok = await showModal({
                  title: 'Delete profile',
                  body: `Delete profile "${p.name}"?`,
                  okText: 'Delete',
                  cancelText: 'Cancel'
                });
                if (!ok) return;
                await fetch(`/api/profiles/${p.id}`, { method: 'DELETE' });
                await loadProfilesList();
              })();
            } else {
              // View profile details (toggle behavior)
              if (currentEditingProfileId === p.id && settingsPanel.style.display === 'block') {
                // Clicking the same profile that's currently displayed - collapse it
                settingsPanel.style.display = 'none';
                currentEditingProfileId = null;
              } else {
                // Clicking a different profile or expanding - show it
              currentEditingProfileId = p.id;
              settingsPanel.style.display = 'block';
              cfgMailUser.value = p.mailUser || '';
              cfgMailPass.value = p.mailPass || '';
              cfgImapHost.value = p.imapHost || '';
              cfgImapPort.value = p.imapPort || '';
              cfgImapTls.value = p.imapTls || 'true';
              cfgSmtpHost.value = p.smtpHost || '';
              cfgSmtpPort.value = p.smtpPort || '';
              cfgSmtpSecure.value = p.smtpSecure || 'true';
              cfgPort.value = p.port || '';
              }
            }
          };
          profilesListEl.appendChild(item);
        });
      } catch (err) {
        await showCopyableError('Load Profiles Error', `Error: ${err.message}`);
      }
    }

    async function createDefaultProfile() {
      try {
        // Get current config from server
        const configRes = await fetch('/api/config', { cache: 'no-cache' });
        const configData = await configRes.json();
        const cfg = configData.config || {};

        // Default profile: longriver.com
        const res = await fetch('/api/profiles', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: 'longriver.com',
            remark: 'longriver.com',
            mailUser: cfg.MAIL_USER || '',
            mailPass: cfg.MAIL_PASS || '',
            imapHost: cfg.IMAP_HOST || 'imap.bbmail.com.hk',
            imapPort: Number(cfg.IMAP_PORT) || 993,
            imapTls: cfg.IMAP_TLS || 'true',
            smtpHost: cfg.SMTP_HOST || 'homegw.bbmail.com.hk',
            smtpPort: Number(cfg.SMTP_PORT) || 465,
            smtpSecure: cfg.SMTP_SECURE || 'true',
            port: Number(cfg.PORT) || 3001,
            isActive: 1
          })
        });
        const data = await res.json();
        if (!data.success) {
          console.error('Failed to create default profile:', data);
        }

        // Additional profile: lcf
        const resLcf = await fetch('/api/profiles', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: 'lcf',
            remark: 'lcf',
            mailUser: 'weiwu@fuchanghk.com',
            mailPass: 'mrkE190#',
            imapHost: 'imap.qiye.163.com',
            imapPort: 993,
            imapTls: 'true',
            smtpHost: 'smtp.qiye.163.com',
            smtpPort: 994,
            smtpSecure: 'true',
            port: 3001,
            isActive: 0
          })
        });
        const dataLcf = await resLcf.json();
        if (!dataLcf.success) {
          console.error('Failed to create lcf profile:', dataLcf);
        }
      } catch (err) {
        console.error('Error creating default profile:', err);
      }
    }

    // Initial state: Welcome tab
    ensureTab('welcome', 'Welcome');
    activateTab('welcome');

    const menuEmailBtn = document.getElementById('menuEmail');
    const sidebar = document.getElementById('sidebar');

    // Menu click: show emails
    menuEmailBtn.onclick = () => {
      ensureTab('emails', 'Email');
      activateTab('emails');
      load(); // Load emails
    };

    // Hover on entire sidebar to show full text
    sidebar.onmouseenter = () => {
      menuEmailBtn.textContent = menuEmailBtn.dataset.full || 'Email';
      menuSettingsBtn.textContent = menuSettingsBtn.dataset.full || 'Setting';
    };
    sidebar.onmouseleave = () => {
      menuEmailBtn.textContent = menuEmailBtn.dataset.short || 'E';
      menuSettingsBtn.textContent = menuSettingsBtn.dataset.short || 'S';
    };

    // Menu click: show profiles list (settings landing page)
    menuSettingsBtn.onclick = () => {
      ensureTab('profiles', 'Setting');
      activateTab('profiles');
      loadProfilesList();
    };

    // Add profile button
    addProfileBtn.onclick = () => {
      // Show blank form for new profile input
      settingsPanel.style.display = 'block';
      currentEditingProfileId = null; // create mode
      cfgMailUser.value = '';
      cfgMailPass.value = '';
      cfgImapHost.value = '';
      cfgImapPort.value = '';
      cfgImapTls.value = 'true';
      cfgSmtpHost.value = '';
      cfgSmtpPort.value = '';
      cfgSmtpSecure.value = 'true';
      cfgPort.value = '';
    };
    
    async function load(showLoading = true) {
      try {
        // Cancel any existing load request
        if (currentLoadController) {
          
          currentLoadController.abort();
        }
        
        // Create new abort controller for this request
        currentLoadController = new AbortController();
        const controller = currentLoadController;
        
        if (showLoading) {
          const tableBody = document.getElementById('emailTableBody');
          tableBody.innerHTML = '<tr><td colspan="5" style="padding:20px; text-align:center; border:1px solid #000;">Loading emails...</td></tr>';
        } else {

        }
        
        // Add timeout to fetch request
        const timeoutId = setTimeout(() => {
          if (!controller.signal.aborted) {
            
            controller.abort();
          }
        }, 30000); // 30 second timeout
        
        let res;
        try {
          res = await fetch('/api/emails?limit=50', { 
            signal: controller.signal,
            cache: 'no-cache' // Prevent caching
          });
          clearTimeout(timeoutId);
          currentLoadController = null; // Clear on success
        } catch (fetchErr) {
          clearTimeout(timeoutId);
          currentLoadController = null; // Clear on error
          
          if (fetchErr.name === 'AbortError') {
            // Only show error if we were showing loading state
            if (showLoading) {
              throw new Error('Request timeout - server took too long to respond');
            } else {
              // Background refresh failed, just log it
              console.warn('Background refresh failed:', fetchErr.message);
              return;
            }
          }
          throw fetchErr;
        }
        
        
        
        if (!res.ok) {
          const errorText = await res.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch {
            errorData = { error: errorText || `HTTP ${res.status}` };
          }
          const errorMsg = errorData.error || 'Failed to load emails';
          const errorCode = errorData.code ? ` (${errorData.code})` : '';
          const troubleshooting = errorData.troubleshooting ? '\n\nTroubleshooting:\n' + errorData.troubleshooting.join('\n') : '';

          await showCopyableError('Email Loading Error',
            `Error: ${errorMsg}${errorCode}\nStatus: ${res.status}${troubleshooting}\n\nFull details:\n${JSON.stringify(errorData, null, 2)}`
          );
          return;
        }
        
        const data = await res.json();
        
        
        if (!data.success) {
          const tableBody = document.getElementById('emailTableBody');
          tableBody.innerHTML = `<tr><td colspan="5" style="padding:20px; border:1px solid #000; text-align:center;">Error: ${data.error || 'Failed to load emails'}</td></tr>`;
          console.error('API error:', data);
          return;
        }
        
        const emails = data.emails || [];
        
        currentEmails = emails; // Store for reference
        
        // Render the email list (only if showLoading was true, otherwise we're in background)
        if (showLoading) {
          renderEmailList(emails);
        } else {
          // Background refresh - update cache and re-render list
          currentEmails = emails;
          renderEmailList(emails);
        }
      } catch (err) {
        console.error('Load function error:', err);
        // Show error modal for any loading issues
        await showCopyableError('Email Loading Error',
          `Failed to load emails: ${err.message}\n\nThis could be due to:\n‚Ä¢ Network connectivity issues\n‚Ä¢ Email server configuration problems\n‚Ä¢ Authentication failures\n\nStack trace:\n${err.stack || 'N/A'}`
        );
      }
    }
    
    async function show(uid){
      // NOTE: after long idle, the browser may throw "TypeError: Failed to fetch" even though
      // the backend can reconnect. We retry once automatically to avoid showing an error popup.
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      // Show loading state in modal
      document.getElementById('emailModalBody').textContent = 'Loading email...';

      async function fetchEmailOnce(attempt){
        

        // Add timeout to fetch request
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          if (!controller.signal.aborted) {
            
            controller.abort();
          }
        }, 30000); // 30 second timeout

        try {
          const res = await fetch('/api/emails/'+uid, {
            signal: controller.signal,
            cache: 'no-cache'
          });
          clearTimeout(timeoutId);

          

          if (!res.ok) {
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: errorText || `HTTP ${res.status}` };
            }
            const errorMsg = errorData.error || 'Failed to fetch email';
            const errorCode = errorData.code ? ` (Code: ${errorData.code})` : '';
            const fullError = `Error: ${errorMsg}${errorCode}\n\nUID: ${uid}\nStatus: ${res.status}\n\nFull details:\n${JSON.stringify(errorData, null, 2)}`;
            const err = new Error(errorMsg);
            err.__isHttpError = true;
            err.__fullError = fullError;
            throw err;
          }

          const data = await res.json();
          if (!data.success) {
            const errorMsg = data.error || 'Failed to load email';
            const errorCode = data.code ? ` (Code: ${data.code})` : '';
            const fullError = `Error: ${errorMsg}${errorCode}\n\nUID: ${uid}\n\nFull details:\n${JSON.stringify(data, null, 2)}`;
            const err = new Error(errorMsg);
            err.__isApiError = true;
            err.__fullError = fullError;
            throw err;
          }

          return data;
        } catch (fetchErr) {
          clearTimeout(timeoutId);

          // Normalize "idle timeout" style errors so we can retry once.
          const isAbort = fetchErr?.name === 'AbortError';
          const msg = fetchErr?.message || '';
          const isNetwork = msg.includes('Failed to fetch') || msg.includes('NetworkError') || fetchErr instanceof TypeError;
          const isRetryable = isAbort || isNetwork;

          if (isRetryable) {
            const err = new Error(isAbort
              ? 'Request timeout - server took too long to respond'
              : 'Network error - connection lost');
            err.__retryable = true;
            err.__original = fetchErr;
            throw err;
          }

          throw fetchErr;
        }
      }

      let data;
      try {
        data = await fetchEmailOnce(1);
      } catch (err1) {
        // Retry once automatically for idle network/timeout issues
        if (err1?.__retryable) {
          // Inform user we are reconnecting, but do not show any popup
          document.getElementById('d-body').textContent = 'Connection timed out (idle). Reconnecting??(retrying)';
          
          // Refresh email list/cache in the background so we truly "reconnect"
          try {
            await load(false);
          } catch (loadErr) {
            console.warn('Background reconnect (list reload) failed:', loadErr);
          }

          await sleep(500); // small pause so reconnect can settle

          try {
            // Second attempt to fetch the same email after reconnect
            data = await fetchEmailOnce(2);
          } catch (err2) {
            // Show error in modal
            console.warn('Email fetch failed after retry:', err2);
            document.getElementById('emailModalBody').textContent = 'Failed to load email. Please try again.';
            return;
          }
        } else if (err1?.__fullError) {
          showCopyableError(err1.__isHttpError ? 'Fetch Email Error' : 'Email Error', err1.__fullError);
          console.error('Fetch email error:', err1);
          document.getElementById('emailModal').style.display='none';
          document.body.classList.remove('modal-open');
          return;
        } else {
          const fullError = `Error fetching email: ${err1.message}\n\nUID: ${uid}\n\nStack trace:\n${err1.stack || 'N/A'}`;
          showCopyableError('Network Error', fullError);
          console.error('Fetch error:', err1);
          document.getElementById('emailModal').style.display='none';
          document.body.classList.remove('modal-open');
          return;
        }
      }
        
        // Parse email from source - simplified to just show context/body
        const source = data.source || '';
        let subject = '';
        let from = '';
        let date = '';
        let bodyContent = '';

        // Extract headers
        const subjectMatch = source.match(/^Subject:\s*(.+)$/mi);
        const fromMatch = source.match(/^From:\s*(.+)$/mi);
        const dateMatch = source.match(/^Date:\s*(.+)$/mi);

        if (subjectMatch) subject = subjectMatch[1].trim();
        if (fromMatch) from = fromMatch[1].trim();
        if (dateMatch) date = dateMatch[1].trim();

        // Extract just the actual email content (skip headers and boundaries)
        const headerEndMatch = source.match(/\n\n|\r\n\r\n/);
        if (headerEndMatch) {
          const bodyPart = source.substring(headerEndMatch.index + headerEndMatch[0].length);

          // Simple approach: find the first actual content after headers
          // Look for content that comes after Content-Type declarations
          const lines = bodyPart.split('\n');
          let contentStart = -1;

          for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes('Content-Type:') && lines[i+1] && lines[i+1].includes('Content-Transfer-Encoding:')) {
              // Found a content section, the actual content starts 2 lines after the encoding line
              contentStart = i + 2;
              break;
            }
          }

          if (contentStart >= 0 && contentStart < lines.length) {
            // Collect content until we hit a boundary
            const contentLines = [];
            for (let i = contentStart; i < lines.length; i++) {
              if (lines[i].startsWith('----_')) {
                break; // Stop at boundary
              }
              contentLines.push(lines[i]);
            }
            bodyContent = contentLines.join('\n').trim();
          } else {
            // Fallback: just remove boundaries and show what's left
            bodyContent = bodyPart.replace(/----_[^\n]*\n/g, '').replace(/Content-Type:[^\n]*\n/g, '').replace(/Content-Transfer-Encoding:[^\n]*\n/g, '').replace(/^\n+/, '').replace(/\n+$/, '');
          }
        } else {
          // Fallback: show the whole source
          bodyContent = source;
        }

        // Display just the actual message content
        document.getElementById('emailModalBody').textContent = bodyContent || 'No content available';

        // Display email metadata in modal
        document.getElementById('emailModalSubject').textContent = subject || '(No subject)';
        document.getElementById('emailModalFrom').textContent = `From: ${from || 'Unknown'}`;
        document.getElementById('emailModalDate').textContent = `Date: ${date || 'Unknown'}`;

        // Extract plain email address from From header if possible
        let emailAddress = null;
        if (from) {
          const m = from.match(/<([^>]+)>/);
          emailAddress = m ? m[1].trim() : from.trim();
        }

        // Remember current email meta for task creation
        currentEmailMeta = {
          uid,
          subject: subject || '',
          from: from || '',
          email: emailAddress || null,
          date: date || ''
        };

        // Show email modal
        populateEmailModal(subject, from, date, bodyContent, currentEmailMeta);
        document.getElementById('emailModal').style.display='flex';
        document.body.classList.add('modal-open');
    }
    
    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randPick(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randString(len) {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let out = '';
      for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
      return out;
    }

    function fillFormDummy(container, { includeHidden = false } = {}) {
      const inputs = Array.from(container.querySelectorAll('input'));
      const textareas = Array.from(container.querySelectorAll('textarea'));

      const fillInput = (input) => {
        if (input.disabled) return;
        if (input.type === 'button' || input.type === 'submit' || input.type === 'reset') return;
        if (!includeHidden && (input.type === 'hidden' || input.offsetParent === null)) return;

        const id = (input.id || '').toLowerCase();
        const name = (input.name || '').toLowerCase();
        const key = `${id} ${name}`;

        if (input.type === 'email' || key.includes('mail_user') || key.includes('user') || key.includes('email')) {
          const domain = randPick(['example.com', 'longriver.com', 'test.local']);
          input.value = `user.${randString(6)}@${domain}`;
        } else if (input.type === 'password' || key.includes('pass')) {
          input.value = `P@ss${randString(10)}!`;
        } else if (input.type === 'number' || key.includes('port')) {
          // reasonable defaults for known ports
          if (key.includes('imap')) input.value = String(randPick([993, 143]));
          else if (key.includes('smtp')) input.value = String(randPick([465, 587, 25]));
          else input.value = String(randPick([3001, 3000, 8080, randInt(1024, 65535)]));
        } else if (key.includes('tls') || key.includes('secure')) {
          input.value = randPick(['true', 'false']);
        } else if (key.includes('host')) {
          const host = randPick(['imap.qiye.163.com', 'smtp.qiye.163.com', 'imap.bbmail.com.hk', 'homegw.bbmail.com.hk', 'mail.example.com']);
          input.value = host;
        } else {
          input.value = randString(10);
        }

        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      };

      const fillTextarea = (ta) => {
        if (ta.disabled) return;
        if (!includeHidden && ta.offsetParent === null) return;
        ta.value = `Dummy content ${randString(12)}\n\nLine 2 ${randString(8)}`;
        ta.dispatchEvent(new Event('input', { bubbles: true }));
        ta.dispatchEvent(new Event('change', { bubbles: true }));
      };

      inputs.forEach(fillInput);
      textareas.forEach(fillTextarea);
    }

    // Copyable modal in minimal black & white style (no browser popups)
    async function showCopyableError(title, errorText) {
      await showModal({
        title,
        body: errorText,
        copyText: errorText,
        okText: 'Close'
      });
    }

    // Minimal black & white modal (replaces alert/confirm)
    function showModal({ title = 'Message', body = '', copyText = null, okText = 'OK', cancelText = null }) {
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';

        const modal = document.createElement('div');
        modal.className = 'modal';

        const header = document.createElement('div');
        header.className = 'modal-header';
        header.textContent = title;

        const content = document.createElement('div');
        content.className = 'modal-body';
        content.textContent = body;

        const actions = document.createElement('div');
        actions.className = 'modal-actions';

        const okBtn = document.createElement('button');
        okBtn.className = 'btn primary';
        okBtn.textContent = okText;

        const close = (result) => {
          try { document.body.removeChild(overlay); } catch {}
          resolve(result);
        };

        okBtn.onclick = () => close(true);

        if (copyText) {
          const copyBtn = document.createElement('button');
          copyBtn.className = 'btn';
          copyBtn.textContent = 'Copy';
          copyBtn.onclick = async () => {
            try {
              await navigator.clipboard.writeText(copyText);
              copyBtn.textContent = 'Copied';
              setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
            } catch (e) {
              // Fallback: select-able content already in body
              copyBtn.textContent = 'Copy failed';
              setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
            }
          };
          actions.appendChild(copyBtn);
        }

        if (cancelText) {
          const cancelBtn = document.createElement('button');
          cancelBtn.className = 'btn';
          cancelBtn.textContent = cancelText;
          cancelBtn.onclick = () => close(false);
          actions.appendChild(cancelBtn);
        }

        actions.appendChild(okBtn);

        modal.appendChild(header);
        modal.appendChild(content);
        modal.appendChild(actions);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // Close on clicking overlay (only for non-confirm)
        overlay.onclick = (e) => {
          if (e.target === overlay && !cancelText) close(true);
        };

        // ESC closes (OK for non-confirm, Cancel for confirm)
        const onKey = (e) => {
          if (e.key === 'Escape') {
            document.removeEventListener('keydown', onKey);
            close(cancelText ? false : true);
          }
        };
        document.addEventListener('keydown', onKey);
      });
    }

    // Text input modal (replaces prompt)
    function showTextInputModal({ title = 'Input', label = '', initialValue = '', okText = 'OK', cancelText = 'Cancel' }) {
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';

        const modal = document.createElement('div');
        modal.className = 'modal';

        const header = document.createElement('div');
        header.className = 'modal-header';
        header.textContent = title;

        const content = document.createElement('div');
        content.className = 'modal-body';

        const labelEl = document.createElement('div');
        labelEl.style.fontWeight = '700';
        labelEl.style.marginBottom = '8px';
        labelEl.textContent = label;

        const input = document.createElement('input');
        input.type = 'text';
        input.value = initialValue || '';

        content.appendChild(labelEl);
        content.appendChild(input);

        const actions = document.createElement('div');
        actions.className = 'modal-actions';

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn';
        cancelBtn.textContent = cancelText;

        const okBtn = document.createElement('button');
        okBtn.className = 'btn primary';
        okBtn.textContent = okText;

        const close = (result) => {
          try { document.body.removeChild(overlay); } catch {}
          resolve(result);
        };

        cancelBtn.onclick = () => close({ ok: false, value: input.value });
        okBtn.onclick = () => close({ ok: true, value: input.value });

        actions.appendChild(cancelBtn);
        actions.appendChild(okBtn);

        modal.appendChild(header);
        modal.appendChild(content);
        modal.appendChild(actions);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        overlay.onclick = (e) => {
          if (e.target === overlay) close({ ok: false, value: input.value });
        };

        const onKey = (e) => {
          if (e.key === 'Escape') {
            document.removeEventListener('keydown', onKey);
            close({ ok: false, value: input.value });
          }
          if (e.key === 'Enter') {
            document.removeEventListener('keydown', onKey);
            close({ ok: true, value: input.value });
          }
        };
        document.addEventListener('keydown', onKey);

        // focus after attach
        setTimeout(() => {
          input.focus();
          input.select();
        }, 0);
      });
    }
    

    
    // Function to populate and show email modal
    function populateEmailModal(subject, from, date, body, emailMeta) {
      document.getElementById('emailModalSubject').textContent = subject || '(No subject)';
      document.getElementById('emailModalFrom').textContent = `From: ${from || 'Unknown'}`;
      document.getElementById('emailModalDate').textContent = `Date: ${date || 'Unknown'}`;

      // Process email body content
      let processedBody = body || 'No content available';

      // Try to clean up the email body (remove headers, etc.)
      if (processedBody.includes('\n\n')) {
        const parts = processedBody.split('\n\n');
        // Skip headers and find the actual content
        for (let i = 0; i < parts.length; i++) {
          if (!parts[i].includes(':') || parts[i].includes('Content-Type: text/html') || parts[i].includes('Content-Type: text/plain')) {
            processedBody = parts.slice(i).join('\n\n');
            break;
          }
        }
      }

      // If it's HTML content, try to extract plain text or display as HTML
      if (processedBody.includes('<div') || processedBody.includes('<p>')) {
        // For HTML content, we can display it as HTML
        document.getElementById('emailModalBody').innerHTML = processedBody.replace(/\n/g, '<br>');
      } else {
        // Plain text content
        document.getElementById('emailModalBody').textContent = processedBody;
      }

      // Store current email meta for task creation
      currentEmailModalMeta = emailMeta;
    }

    // Helper function to render email list
    function renderEmailList(emails) {
      const tableBody = document.getElementById('emailTableBody');
      tableBody.innerHTML='';

      if (emails.length === 0) {
        const noEmailsRow = document.createElement('tr');
        noEmailsRow.innerHTML = '<td colspan="5" style="padding:20px; text-align:center; border:1px solid #000;">No emails found in inbox</td>';
        tableBody.appendChild(noEmailsRow);
        return;
      }

      emails.forEach(e=>{
        const row = document.createElement('tr');
        row.style.cursor = 'pointer';
        row.style.border = '1px solid #000';

        // Format date
        const date = new Date(e.date);
        const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

        // Extract sender email from from field
        let senderEmail = '';
        const fromMatch = (e.from || '').match(/<([^>]+)>/);
        if (fromMatch) {
          senderEmail = fromMatch[1];
        } else {
          senderEmail = e.from || '';
        }

        // For now, we'll use placeholder data for context and attachments since they're not available in the current email data structure
        const context = '<span style="cursor:pointer; font-weight:500;">Click to view</span>'; // Placeholder with clickable styling
        const attachment = 'N/A'; // Placeholder - would need to be extracted from email headers

        row.innerHTML = `
          <td style="padding:12px; border:1px solid #000; vertical-align:top;">${formattedDate}</td>
          <td style="padding:12px; border:1px solid #000; vertical-align:top;">${senderEmail}</td>
          <td style="padding:12px; border:1px solid #000; vertical-align:top;">${e.subject||'No subject'}</td>
          <td style="padding:12px; border:1px solid #000; vertical-align:top;">${context}</td>
          <td style="padding:12px; border:1px solid #000; vertical-align:top;">${attachment}</td>
        `;

        tableBody.appendChild(row);

        // Add event listeners after appending to DOM
        row.onmouseover = () => row.style.background = 'rgba(0, 0, 0, 0.3)';
        row.onmouseout = () => row.style.background = '#fff';
        row.onclick = (event) => {
          console.log('Row clicked for email UID:', e.uid, event.target);
          show(e.uid);
        };
      });

    }

    // Search functionality
    let currentFilteredEmails = [];

    function filterEmails() {
      const dateSearch = document.getElementById('dateSearch').value.toLowerCase();
      const senderSearch = document.getElementById('senderSearch').value.toLowerCase();
      const subjectSearch = document.getElementById('subjectSearch').value.toLowerCase();
      const contextSearch = document.getElementById('contextSearch').value.toLowerCase();
      const attachmentSearch = document.getElementById('attachmentSearch').value.toLowerCase();

      currentFilteredEmails = currentEmails.filter(email => {
        const date = new Date(email.date).toLocaleDateString().toLowerCase();
        const sender = (email.from || '').toLowerCase();
        const subject = (email.subject || '').toLowerCase();
        const context = '(click to view)'; // Placeholder for now
        const attachment = 'n/a'; // Placeholder for now

        return date.includes(dateSearch) &&
               sender.includes(senderSearch) &&
               subject.includes(subjectSearch) &&
               context.includes(contextSearch) &&
               attachment.includes(attachmentSearch);
      });

      renderEmailList(currentFilteredEmails);
    }

    // Add event listeners for search inputs
    document.getElementById('dateSearch').addEventListener('input', filterEmails);
    document.getElementById('senderSearch').addEventListener('input', filterEmails);
    document.getElementById('subjectSearch').addEventListener('input', filterEmails);
    document.getElementById('contextSearch').addEventListener('input', filterEmails);
    document.getElementById('attachmentSearch').addEventListener('input', filterEmails);
    
    // Compose email handlers
    const composeBtn = document.getElementById('composeBtn');
    const composeForm = document.getElementById('composeForm');
    const cancelBtn = document.getElementById('cancelBtn');
    const sendBtn = document.getElementById('sendBtn');
    const testSendBtn = document.getElementById('testSendBtn');
    const dummyFillComposeBtn = document.getElementById('dummyFillComposeBtn');
    if (dummyFillComposeBtn) {
      dummyFillComposeBtn.onclick = () => {
        fillDummyForm(composeForm);
      };
    }
    
    composeBtn.onclick = () => {
      composeForm.style.display = composeForm.style.display === 'none' ? 'block' : 'none';
    };
    
    cancelBtn.onclick = () => {
      composeForm.style.display = 'none';
      document.getElementById('toEmail').value = '';
      document.getElementById('subjectEmail').value = '';
      document.getElementById('bodyEmail').value = '';
    };
    
    sendBtn.onclick = async () => {
      const to = document.getElementById('toEmail').value;
      const subject = document.getElementById('subjectEmail').value;
      const text = document.getElementById('bodyEmail').value;
      
      if (!to || !subject || !text) {
        await showModal({ title: 'Missing fields', body: 'Please fill in: To, Subject, and Message.' });
        return;
      }
      
      try {
        sendBtn.disabled = true;
        sendBtn.textContent = 'Sending...';
        
        // Add timeout to fetch request (increased for idle reconnection)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          if (!controller.signal.aborted) {
            controller.abort();
          }
        }, 60000); // 60 second timeout (increased to allow for SMTP reconnection)
        
        let res;
        try {
          res = await fetch('/api/email/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ to, subject, text }),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
        } catch (fetchErr) {
          clearTimeout(timeoutId);
          if (fetchErr.name === 'AbortError') {
            throw new Error('Request timeout - server took too long to respond');
          }
          throw new Error(`Network error: ${fetchErr.message}`);
        }
        
        if (!res.ok) {
          const errorText = await res.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch {
            errorData = { error: errorText || `HTTP ${res.status}` };
          }
          const errorMsg = errorData.error || 'Failed to send email';
          const errorCode = errorData.code ? ` (Code: ${errorData.code})` : '';
          const fullError = `Error sending email:\n${errorMsg}${errorCode}\n\nStatus: ${res.status}\n\nFull details:\n${JSON.stringify(errorData, null, 2)}`;
          showCopyableError('Send Email Error', fullError);
          console.error('Send email error:', errorData);
          return;
        }
        
        const data = await res.json();
        if (data.success) {
          await showModal({
            title: 'Sent',
            body: `Email sent successfully.\nMessage ID: ${data.messageId || 'N/A'}`,
          });
          composeForm.style.display = 'none';
          document.getElementById('toEmail').value = '';
          document.getElementById('subjectEmail').value = '';
          document.getElementById('bodyEmail').value = '';
        } else {
          const errorMsg = data.error || 'Unknown error';
          const errorCode = data.code ? ` (Code: ${data.code})` : '';
          const errorText = `Error sending email:\n${errorMsg}${errorCode}\n\nFull details:\n${JSON.stringify(data, null, 2)}`;
          showCopyableError('Send Email Error', errorText);
          console.error('Send email error:', data);
        }
      } catch (err) {
        const errorText = `Error sending email: ${err.message}\n\nStack trace:\n${err.stack || 'N/A'}`;
        showCopyableError('Send Email Error', errorText);
        console.error('Send email error:', err);
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
      }
    };
    
    // Test SMTP connection
    const testSmtpBtn = document.getElementById('testSmtpBtn');
    testSmtpBtn.onclick = async () => {
      try {
        testSmtpBtn.disabled = true;
        testSmtpBtn.textContent = 'Testing...';
        
        const res = await fetch('/api/smtp/test');
        const data = await res.json();
        if (data.success) {
          await showModal({
            title: 'SMTP OK',
            body: `SMTP connection successful.\nHost: ${data.host}\nPort: ${data.port}\nSecure: ${data.secure ? 'SSL/TLS' : 'STARTTLS'}`,
          });
        } else {
          const errorMsg = data.error || 'Unknown error';
          const errorCode = data.code ? ` (Code: ${data.code})` : '';
          const errorText = `??SMTP Connection Failed:\n${errorMsg}${errorCode}\n\nHost: ${data.host || 'N/A'}\nPort: ${data.port || 'N/A'}\nSecure: ${data.secure ? 'SSL/TLS' : 'STARTTLS'}\n\n${data.troubleshooting || ''}\n\nFull details:\n${JSON.stringify(data, null, 2)}`;
          showCopyableError('SMTP Connection Error', errorText);
          console.error('SMTP test error:', data);
        }
      } catch (err) {
        showCopyableError('SMTP Test Error', `Error testing SMTP: ${err.message}\n\nStack trace:\n${err.stack || 'N/A'}`);
        console.error('SMTP test error:', err);
      } finally {
        testSmtpBtn.disabled = false;
        testSmtpBtn.textContent = '?? Test SMTP Connection';
      }
    };
    
    // Test send email to eric.brilliant@gmail.com
    testSendBtn.onclick = async () => {
      const ok = await showModal({
        title: 'Send test email',
        body: 'Send test email to eric.brilliant@gmail.com?',
        okText: 'Send',
        cancelText: 'Cancel'
      });
      if (!ok) return;
      try {
        testSendBtn.disabled = true;
        testSendBtn.textContent = 'Sending...';
        const res = await fetch('/api/email/test', { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          await showModal({ title: 'Sent', body: `Test email sent successfully to ${data.to}!` });
        } else {
          const errorMsg = data.error || 'Unknown error';
          const errorCode = data.code ? ` (Code: ${data.code})` : '';
          const errorText = `Test Email Error:\n${errorMsg}${errorCode}\n\nFull details:\n${JSON.stringify(data, null, 2)}`;
          showCopyableError('Test Email Error', errorText);
          console.error('Test email error:', data);
        }
      } catch (err) {
        showCopyableError('Test Email Error', `Error: ${err.message}\n\nStack trace:\n${err.stack || 'N/A'}`);
      } finally {
        testSendBtn.disabled = false;
        testSendBtn.textContent = '?ÔøΩÔøΩ Send Test Email';
      }
    };

    // Email modal event listeners
    document.getElementById('emailModalClose').onclick = () => {
      document.getElementById('emailModal').style.display = 'none';
      document.body.classList.remove('modal-open');
    };

    document.getElementById('emailModal').onclick = (e) => {
      if (e.target === document.getElementById('emailModal')) {
        document.getElementById('emailModal').style.display = 'none';
        document.body.classList.remove('modal-open');
      }
    };

    document.getElementById('emailModalCreateTask').onclick = async () => {
      try {
        if (!currentEmailModalMeta || !currentEmailModalMeta.uid) {
          await showModal({
            title: 'No email selected',
            body: 'No email is currently open in the modal.'
          });
          return;
        }

        const payload = {
          type: 'erp-enquiry',
          status: 'new',
          sourceEmailUid: currentEmailModalMeta.uid,
          sourceSubject: currentEmailModalMeta.subject,
          customerEmail: currentEmailModalMeta.email
        };

        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          if (!controller.signal.aborted) controller.abort();
        }, 15000);

        let res;
        try {
          res = await fetch('/api/tasks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
        } catch (err) {
          clearTimeout(timeoutId);
          const msg = err.name === 'AbortError'
            ? 'Request timeout while creating task.'
            : `Network error while creating task: ${err.message}`;
          await showModal({ title: 'Create Task Error', body: msg });
          return;
        }

        const text = await res.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch {
          data = { success: false, error: text || 'Invalid JSON response from server' };
        }

        if (!res.ok || !data.success) {
          const fullError = `Error creating task\n\nStatus: ${res.status}\nPayload:\n${JSON.stringify(payload, null, 2)}\n\nResponse:\n${JSON.stringify(data, null, 2)}`;
          await showCopyableError('Create Task Error', fullError);
          return;
        }

        const task = data.task || {};
        await showModal({
          title: 'Task Created',
          body: `Task #${task.id} created from email.\nType: ${task.type}\nStatus: ${task.status}`
        });
      } catch (err) {
        const fullError = `Unexpected error creating task:\n${err.message}\n\nStack:\n${err.stack || 'N/A'}`;
        await showCopyableError('Create Task Error', fullError);
      }
    };

    load();
  </script>
</body>
</html>

